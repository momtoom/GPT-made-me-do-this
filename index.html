<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Vibe Murmuration 3D — Letter Debug Build</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Host+Grotesk:wght@600&display=swap" rel="stylesheet">
  <style>
    html,body{margin:0;height:100%;background:#0b0d10;overflow:hidden}
    #app{position:fixed;inset:0}
    #debug{position:fixed;left:12px;bottom:12px;color:#8fa;opacity:.9;font:12px/1.2 ui-monospace,monospace;white-space:pre}
    #hint{position:fixed;left:12px;top:12px;color:#89a;opacity:.85;font:12px/1.2 ui-monospace,monospace}
    canvas{touch-action:none}
  </style>
</head>
<body>
  <div id="app"></div>
  <div id="debug"></div>
  <div id="hint">SPACE: 전체 결집/해산 · 마우스/터치: 글자 위에서 윤곽 드러남</div>

  <script type="module">
    import * as THREE from './lib/three.module.js';
    import { OrbitControls } from './lib/OrbitControls.js';

    const dbg = document.getElementById('debug');
    const log = (s)=>{ if(dbg) dbg.textContent = s; };

    // ---------- 파라미터 (디버그에 유리하게 조정) ----------
    const TEXT_LINES = [
      'SPENT HOURS BACKFLOW',
      'SLOWLY RISING ROUND MY SKIN',
      'FOG DISSOLVES THE WALLS'
    ];
    const FONT_FAMILY = "'Host Grotesk', sans-serif";
    const GRID_STEP = 1.6;      // 글자 포인트 촘촘도
    const SWARM_DENSITY = 260;  // 화면 크기에 따른 입자 수
    const MAX_PARTICLES = 15000;

    const DOT_SIZE_BASE = 0.018;     // 점 크기 키움 (안 보임 방지)
    const DAMP = 0.985, MAX_SPD = 1.25;
    const MOUSE_PULL = 0.65;
    const SPRING_TEXT = 14.0;        // 타깃 스프링 강도
    const RELEASE_DELAY = 450;

    const REVEAL_RADIUS = 0.22;
    const CLAIM_BATCH = 900;
    const PARTICLE_CLAIM_RADIUS = 0.22;
    const UNCLAIM_DIST = 0.06;

    // ---------- 씬 ----------
    const el = document.getElementById('app');
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.01, 30);
    camera.position.set(0, 0, 1.7);

    const renderer = new THREE.WebGLRenderer({ antialias:false, alpha:false, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 1.6));
    renderer.setSize(innerWidth, innerHeight);
    el.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enableZoom = false;
    controls.enablePan = false;

    scene.fog = new THREE.FogExp2(0x0b0d10, 0.18);

    // ---------- 글자 샘플링 (여기 위치에 둔다) ----------
    async function makeTextPoints(){
      // 폰트 로드 완료 대기 (중요!)
      await document.fonts.ready;

      const W = 1200, H = 520;
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = W; canvas.height = H;

      ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#fff';
      ctx.font = `600 66px ${FONT_FAMILY}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      const lineH = 96;
      const baseY = H/2 - lineH;
      TEXT_LINES.forEach((t,i)=> ctx.fillText(t, W/2, baseY + i*lineH));

      const img = ctx.getImageData(0,0,W,H).data;
      const step = GRID_STEP;
      const pts = [];
      let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;

      // ★ 디버그 단계: NDC 기반 "단순 좌표" 매핑으로 글자 모양부터 보이게 한다
      for(let y=0; y<H; y+=step){
        for(let x=0; x<W; x+=step){
          const a = img[(y*W+x)*4 + 3];
          if(a>140){
            const nx = (x/W)*2 - 1;      // -1..+1
            const ny = (y/H)*2 - 1;      // -1..+1
            const wx = nx * 0.9;         // 화면에 잘 들어오게 스케일
            const wy = -ny * 0.5;        // 세로 압축(필요시 0.9로)
            pts.push({x:wx, y:wy});
            if(wx<minX)minX=wx; if(wx>maxX)maxX=wx;
            if(wy<minY)minY=wy; if(wy>maxY)maxY=wy;
          }
        }
      }
      const rect = { x:minX, y:maxY, w:(maxX-minX), h:(minY-maxY) };
      return { pts, rect };
    }

    // ---------- 텍스트 포인트 생성 및 확인 ----------
    let textPoints = [], textRect = null;
    let textTargets = [], nTargets = 0;

    // 파티클/타깃 버퍼
    let particleCount, geom, positions, velocities, targets, targetIdx, ptOwner, DOT_SIZE;

    // ---------- 초기화 전체를 한 번에 ----------
    (async function init(){
      const res = await makeTextPoints();
      textPoints = res.pts; textRect = res.rect;
      textTargets = textPoints.slice(0);
      nTargets = textTargets.length;

      // 디버그 출력
      console.log('textPoints length =', nTargets);
      dbg.textContent = `textPoints=${nTargets}`;

      // 포인트가 0이면 폰트 문제 가능 → 시스템 폰트로 재시도 안내
      if(nTargets === 0){
        const warn = 'Warning: textPoints=0 (폰트 로드/렌더 문제 가능). ctx.font를 "bold 66px Arial"로 바꿔 테스트해봐.';
        console.warn(warn);
      }

      // 파티클 준비
      particleCount = Math.min(MAX_PARTICLES, Math.floor((innerWidth*innerHeight)/SWARM_DENSITY));
      particleCount = Math.max(Math.min(nTargets*1.3|0, MAX_PARTICLES), 1800);

      DOT_SIZE = Math.max(DOT_SIZE_BASE, Math.min(0.024, DOT_SIZE_BASE * (800/Math.max(innerWidth, innerHeight)) * 1.6));

      geom = new THREE.BufferGeometry();
      positions = new Float32Array(particleCount*3);
      velocities = new Float32Array(particleCount*3);
      targets   = new Float32Array(particleCount*3);
      targetIdx = new Int32Array(particleCount);
      ptOwner   = new Int32Array(nTargets);

      geom.setAttribute('position', new THREE.BufferAttribute(positions,3));
      geom.setAttribute('velocity', new THREE.BufferAttribute(velocities,3));
      geom.setAttribute('target',   new THREE.BufferAttribute(targets,3));

      const mat = new THREE.PointsMaterial({
        color:0xffffff, size:DOT_SIZE, sizeAttenuation:true, transparent:true, opacity:0.92, depthWrite:false
      });
      const points = new THREE.Points(geom, mat);
      scene.add(points);

      // 경계
      const bounds = {};
      function computeBounds(){
        const halfY = Math.tan(THREE.MathUtils.degToRad(camera.fov)*0.5)*camera.position.z;
        const halfX = halfY*camera.aspect;
        bounds.minX=-halfX-0.04; bounds.maxX=halfX+0.04;
        bounds.minY=-halfY-0.04; bounds.maxY=halfY+0.04;
      }
      computeBounds();

      // 초기화
      for(let i=0;i<particleCount;i++){
        positions[i*3]   = THREE.MathUtils.lerp(bounds.minX,bounds.maxX,Math.random());
        positions[i*3+1] = THREE.MathUtils.lerp(bounds.minY,bounds.maxY,Math.random());
        positions[i*3+2] = (Math.random()*2-1)*0.7;

        velocities[i*3]   = (Math.random()-0.5)*0.25;
        velocities[i*3+1] = (Math.random()-0.5)*0.25;
        velocities[i*3+2] = (Math.random()-0.5)*0.07;

        targets[i*3]=999; targets[i*3+1]=999; targets[i*3+2]=0;
        targetIdx[i]=-1;
      }
      for(let t=0;t<nTargets;t++) ptOwner[t] = -1;

      // 입력
      const mouseNdc=new THREE.Vector2(), mouseWorld=new THREE.Vector3(), mouseLocal=new THREE.Vector3();
      const plane=new THREE.Plane(new THREE.Vector3(0,0,1),0);
      const raycaster=new THREE.Raycaster();

      let mouseActive=false, touchMode=false, lastOnTextMs=0, assembleAll=false;

      function setFromClient(x,y){
        mouseNdc.x = (x/innerWidth)*2-1;
        mouseNdc.y = -(y/innerHeight)*2+1;
        raycaster.setFromCamera(mouseNdc, camera);
        raycaster.ray.intersectPlane(plane, mouseWorld);
        mouseLocal.copy(mouseWorld);
        points.worldToLocal(mouseLocal);
        mouseActive = true;
      }
      function onPointer(e){ setFromClient(e.clientX, e.clientY); }
      addEventListener('pointermove', onPointer, {passive:true});
      addEventListener('pointerdown', onPointer, {passive:true});

      renderer.domElement.addEventListener('touchstart', e=>{
        if(!e.touches.length) return;
        touchMode = true; controls.enabled = false;
        setFromClient(e.touches[0].clientX, e.touches[0].clientY);
        e.preventDefault();
      }, {passive:false});
      renderer.domElement.addEventListener('touchmove', e=>{
        if(!e.touches.length) return;
        setFromClient(e.touches[0].clientX, e.touches[0].clientY);
        e.preventDefault();
      }, {passive:false});
      renderer.domElement.addEventListener('touchend', ()=>{
        touchMode=false; controls.enabled=true;
        setTimeout(()=>{ if(!assembleAll) releaseTextAll(); }, RELEASE_DELAY);
      }, {passive:true});

      addEventListener('resize', ()=>{
        camera.aspect = innerWidth/innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth,innerHeight);
        computeBounds();
      });

      addEventListener('keydown', (e)=>{
        if(e.code==='Space'){
          assembleAll = !assembleAll;
          if(!assembleAll) releaseTextAll();
        }
      });

      function mouseOverText(){
        const m=0.02;
        const x=mouseLocal.x, y=mouseLocal.y;
        return (x>textRect.x-m && x<textRect.x+textRect.w+m && y<textRect.y-m && y>textRect.y+textRect.h-m);
      }

      function releaseTextAll(){
        for(let i=0;i<particleCount;i++){
          targets[i*3]=999; targets[i*3+1]=999; targetIdx[i]=-1;
        }
        for(let t=0;t<nTargets;t++) ptOwner[t]=-1;
      }

      function claimAround(cx,cy,maxClaims,matchRadius){
        // 텍스트 포인트 중 가까운 것부터 파티클에 1:1 할당
        let claimed=0;
        const r2 = matchRadius*matchRadius;
        for(let t=0; t<nTargets && claimed<maxClaims; t++){
          if(ptOwner[t] !== -1) continue;
          const tp = textTargets[t];
          const dx0 = tp.x - cx, dy0 = tp.y - cy;
          if(dx0*dx0 + dy0*dy0 > r2) continue;

          let best=-1, bestd=1e9;
          for(let i=0;i<particleCount;i++){
            if(targetIdx[i] !== -1) continue;
            const px=positions[i*3], py=positions[i*3+1];
            const dx=px - tp.x, dy=py - tp.y;
            const d=dx*dx + dy*dy;
            if(d<bestd && d<=r2){ best=i; bestd=d; }
          }
          if(best>=0){
            targetIdx[best]=t; ptOwner[t]=best;
            targets[best*3]=tp.x; targets[best*3+1]=tp.y; targets[best*3+2]=0;
            claimed++;
          }
        }
        return claimed;
      }

      function unclaimFarOnes(){
        const th2 = UNCLAIM_DIST*UNCLAIM_DIST;
        for(let i=0;i<particleCount;i++){
          const ti = targetIdx[i]; if(ti<0) continue;
          const tp = textTargets[ti];
          const dx = positions[i*3]-tp.x, dy = positions[i*3+1]-tp.y;
          if(dx*dx+dy*dy > th2){
            targetIdx[i]=-1; ptOwner[ti]=-1;
            targets[i*3]=999; targets[i*3+1]=999;
          }
        }
      }

      // 루프 (회전 끔: 디버그에 방해)
      function animate(){
        requestAnimationFrame(animate);

        if(mouseActive && mouseOverText()){
          const rr = touchMode ? REVEAL_RADIUS*1.25 : REVEAL_RADIUS;
          const pr = touchMode ? PARTICLE_CLAIM_RADIUS*1.25 : PARTICLE_CLAIM_RADIUS;
          const batch = touchMode ? Math.round(CLAIM_BATCH*1.2) : CLAIM_BATCH;
          const got = claimAround(mouseLocal.x, mouseLocal.y, batch, rr);
          if(got>0) lastOnTextMs = performance.now();
        }else{
          if(performance.now() - lastOnTextMs > RELEASE_DELAY && !assembleAll){
            unclaimFarOnes();
          }
        }

        for(let i=0;i<particleCount;i++){
          const pi=i*3;
          let vx=velocities[pi], vy=velocities[pi+1], vz=velocities[pi+2];
          let px=positions[pi],  py=positions[pi+1],  pz=positions[pi+2];

          const ti = targetIdx[i];
          if(ti>=0){
            const tp=textTargets[ti];
            const dx = tp.x - px, dy = tp.y - py;
            vx += dx * (SPRING_TEXT*0.03);
            vy += dy * (SPRING_TEXT*0.03);
            vz += (0 - pz) * 0.02;
          }else{
            // 자유 입자: 마우스 인력만 약간
            if(mouseActive){
              const dx = mouseLocal.x - px, dy = mouseLocal.y - py;
              const d2 = dx*dx + dy*dy + 1e-4;
              const f = (MOUSE_PULL*0.003) / d2;
              vx += dx*f; vy += dy*f;
            }
          }

          vx *= DAMP; vy *= DAMP; vz *= DAMP;
          const sp = Math.hypot(vx,vy); if(sp>MAX_SPD){ const s=MAX_SPD/sp; vx*=s; vy*=s; }

          px += vx*0.016; py += vy*0.016; pz += vz*0.016;

          // 약한 래핑
          if(px<-1.2) px=1.2; if(px>1.2) px=-1.2;
          if(py<-0.9) py=0.9;  if(py>0.9) py=-0.9;

          velocities[pi]=vx; velocities[pi+1]=vy; velocities[pi+2]=vz;
          positions[pi]=px;  positions[pi+1]=py;  positions[pi+2]=pz;
        }

        geom.attributes.position.needsUpdate = true;
        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      log(`ready · textPts=${nTargets} · particles=${particleCount} · dot=${DOT_SIZE.toFixed(3)}`);
    })();
  </script>
</body>
</html>
