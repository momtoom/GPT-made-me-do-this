<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Vibe Murmuration 3D — hover reveal</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Host+Grotesk:wght@500&display=swap" rel="stylesheet">
  <style>
    html,body{margin:0;height:100%;background:#0b0d10;overflow:hidden}
    #app{position:fixed;inset:0}
    #debug{position:fixed;left:12px;bottom:12px;color:#8fa;opacity:.8;font:12px/1.2 ui-monospace,monospace;white-space:pre}
    #hint{position:fixed;left:12px;top:12px;color:#89a;opacity:.75;font:12px/1.2 ui-monospace,monospace}
  </style>
</head>
<body>
  <div id="app"></div>
  <div id="debug"></div>
  <div id="hint">SPACE: 토글(전체 결집/해산) · 마우스: 글자 위에서만 국소 결집</div>

  <script type="module">
    // ---------- logger & dynamic import
    const dbg = document.getElementById('debug');
    const log = (s)=>{ if(dbg) dbg.textContent = s; };
    async function tryImport(url){ try{ const m=await import(url); log('loaded: '+url); return m; }catch(e){ log('failed: '+url); return null; } }
    async function loadThree(){
      const sources = [
        { core:'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js',
          extra:'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/controls/OrbitControls.js' },
        { core:'https://unpkg.com/three@0.157.0/build/three.module.js',
          extra:'https://unpkg.com/three@0.157.0/examples/jsm/controls/OrbitControls.js' },
        { core:'https://esm.sh/three@0.157.0',
          extra:'https://esm.sh/three@0.157.0/examples/jsm/controls/OrbitControls.js' }
      ];
      for (const s of sources){
        const THREE = await tryImport(s.core); if(!THREE) continue;
        const Ex = await tryImport(s.extra);   if(!Ex) continue;
        return { THREE, OrbitControls: Ex.OrbitControls };
      }
      return null;
    }

    (async ()=>{
      const mod = await loadThree();
      if(!mod){
        const warn = document.createElement('div');
        warn.style.position='fixed'; warn.style.inset='0'; warn.style.display='grid';
        warn.style.placeItems='center'; warn.style.color='#9ad';
        warn.style.font='14px ui-monospace,monospace'; warn.style.textAlign='center';
        warn.innerHTML = `External module import blocked.<br>HTTPS에서 열거나 로컬 브라우저로 파일을 직접 실행하세요.`;
        document.body.appendChild(warn);
        return;
      }
      const { THREE, OrbitControls } = mod;

      // ---------- Parameters (성능+가독)
      const TEXT_LINES = [
        'SPENT HOURS BACKFLOW',
        'SLOWLY RISING ROUND MY SKIN',
        'FOG DISSOLVES THE WALLS'
      ];
      const FONT_FAMILY = "'Host Grotesk', system-ui, -apple-system, Segoe UI, Roboto, sans-serif";

      // 밀도 & 예산
      const GRID_STEP = 2;
      const DOT_SIZE  = 0.014;
      const SWARM_DENSITY = 300;         // 화면면적/300 ≈ 파티클 수 (FHD ~6.9k)
      const MAX_PARTICLES  = 12000;      // 절대 상한

      // 텍스트 포인트 부분 샘플(윤곽만)
      const TEXT_MAP_RATIO = 0.35;       // 전체 중 35%만 사용

      // 동역학
      const CURL_SCALE = 0.28;
      const DAMP       = 0.98;
      const MAX_SPD    = 1.2;
      const MOUSE_PULL = 0.55;

      // 결집(텍스트 리빌)
      const REVEAL_SPRING = 6.8;
      const UNCLAIM_DIST  = 0.012;

      // 분리/해시 (계산량↓)
      const SEP_RADIUS = 0.05;
      const SEP_FORCE  = 0.6;
      const HASH_CELL  = 0.08;
      const FLOCK_EVERY_N = 2;           // 분리 연산 격프레임

      // 깊이/연출
      const Z_RANGE = 0.7;
      const SCENE_SLOW_SPIN = 0.04;

      // Hover reveal
      const REVEAL_RADIUS = 0.28;        // 마우스 근처(월드 단위)에서만 텍스트로 결집
      const CLAIM_BATCH   = 160;         // 프레임당 타깃 부여 개수
      const RELEASE_DELAY = 450;         // 마우스가 글자 밖으로 나간 후 해산 지연(ms)

      // ---------- Scene
      const el = document.getElementById('app');
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 30);
      camera.position.set(0,0,1.7);

      const renderer = new THREE.WebGLRenderer({ antialias:false, alpha:false, powerPreference:'high-performance' });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 1.5));
      renderer.setSize(innerWidth, innerHeight);
      renderer.setClearColor(0x0b0d10, 1);
      el.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; controls.enableZoom = false; controls.enablePan = false;
      scene.fog = new THREE.FogExp2(0x0b0d10, 1.1);

      // 화면 프러스텀 경계(z=0 평면)
      const bounds = { minX:0, maxX:0, minY:0, maxY:0 };
      function computeBounds(){
        const halfY = Math.tan(THREE.MathUtils.degToRad(camera.fov)*0.5) * camera.position.z;
        const halfX = halfY * camera.aspect;
        const padX = 0.04, padY = 0.04; // 살짝 여유
        bounds.minX = -halfX - padX; bounds.maxX = halfX + padX;
        bounds.minY = -halfY - padY; bounds.maxY = halfY + padY;
      }
      computeBounds();

      // ---------- 텍스트 → 포인트(+ world rect)
      function makeTextPoints(){
        const W = Math.max(1280, innerWidth);
        const H = Math.max(720, innerHeight);
        const cvs = document.createElement('canvas');
        cvs.width = W; cvs.height = H;
        const ctx = cvs.getContext('2d', { willReadFrequently:true });

        const base=100; ctx.font = `500 ${base}px ${FONT_FAMILY}`;
        const maxBase = TEXT_LINES.reduce((m,t)=>Math.max(m, ctx.measureText(t).width), 1);
        const target = Math.min(W*0.92, 2600);
        const fontPx = Math.max(18, Math.min(220, Math.round(base*(target/maxBase))));
        const lineH  = Math.round(fontPx*1.25);
        ctx.font = `500 ${fontPx}px ${FONT_FAMILY}`;
        ctx.textBaseline = 'top'; ctx.textAlign='left'; ctx.fillStyle='#fff';

        const maxLineW = TEXT_LINES.reduce((m,t)=>Math.max(m, ctx.measureText(t).width), 0);
        const baseX = Math.round((W - maxLineW)/2);
        const startY = Math.round((H - TEXT_LINES.length*lineH)/2);
        TEXT_LINES.forEach((t,i)=> ctx.fillText(t, baseX, startY + i*lineH));

        const minX = Math.max(0, baseX);
        const maxX = Math.min(W, baseX + maxLineW);
        const minY = Math.max(0, startY);
        const maxY = Math.min(H, startY + TEXT_LINES.length*lineH);

        const img = ctx.getImageData(minX, minY, maxX-minX, maxY-minY);
        const data = img.data, iw=img.width, ih=img.height;

        const pts = [];
        for (let y=0; y<ih; y+=GRID_STEP){
          for (let x=0; x<iw; x+=GRID_STEP){
            const a = data[(y*iw + x)*4 + 3];
            if (a>10){
              const nx = THREE.MathUtils.lerp(bounds.minX, bounds.maxX, (minX + x)/W);
              const ny = THREE.MathUtils.lerp(bounds.minY, bounds.maxY, 1 - (minY + y)/H);
              pts.push(new THREE.Vector3(
                nx + (Math.random()-0.5)*((bounds.maxX-bounds.minX)/W)*6,
                ny + (Math.random()-0.5)*((bounds.maxY-bounds.minY)/H)*6,
                0
              ));
            }
          }
        }
        const rect = {
          x: THREE.MathUtils.lerp(bounds.minX, bounds.maxX, minX/W),
          y: THREE.MathUtils.lerp(bounds.minY, bounds.maxY, 1 - minY/H),
          w: THREE.MathUtils.lerp(0, bounds.maxX-bounds.minX, (maxX-minX)/W),
          h: -THREE.MathUtils.lerp(0, bounds.maxY-bounds.minY, (maxY-minY)/H) // 위가 +
        };
        return { pts, rect };
      }

      // 최초 생성
      let { pts: textPoints, rect: textRect } = makeTextPoints();

      // 텍스트 부분 샘플 + 텍스트용 공간 해시
      let textForMap = [];
      const textHash = new Map();
      function tkey(ix,iy){ return (ix<<16)^iy; }
      const T_HASH = HASH_CELL * 0.8;
      const t_ix = (x)=> Math.floor((x - bounds.minX)/T_HASH);
      const t_iy = (y)=> Math.floor((y - bounds.minY)/T_HASH);

      function rebuildTextMappingAndHash(){
        textForMap = textPoints.filter(()=> Math.random() < TEXT_MAP_RATIO);
        textHash.clear();
        for (let i=0;i<textForMap.length;i++){
          const p = textForMap[i];
          const k = tkey(t_ix(p.x), t_iy(p.y));
          if(!textHash.has(k)) textHash.set(k, []);
          textHash.get(k).push(i);
        }
      }

      // ---------- 파티클 버퍼
      let particleCount = Math.min(MAX_PARTICLES, Math.floor((innerWidth*innerHeight)/SWARM_DENSITY));
      const geom = new THREE.BufferGeometry();
      let positions = new Float32Array(particleCount*3);
      let velocities= new Float32Array(particleCount*3);
      let targets   = new Float32Array(particleCount*3);
      function attachBuffers(){
        geom.setAttribute('position', new THREE.BufferAttribute(positions,3));
        geom.setAttribute('velocity', new THREE.BufferAttribute(velocities,3));
        geom.setAttribute('target',   new THREE.BufferAttribute(targets,3));
      }
      attachBuffers();

      const mat = new THREE.PointsMaterial({
        color: 0xffffff,
        size: DOT_SIZE,
        sizeAttenuation: true,
        transparent: true,
        opacity: 0.85,
        depthWrite: false,
        blending: THREE.NormalBlending
      });
      const points = new THREE.Points(geom, mat);
      scene.add(points);

      function randXY(){ 
        return [
          THREE.MathUtils.lerp(bounds.minX, bounds.maxX, Math.random()),
          THREE.MathUtils.lerp(bounds.minY, bounds.maxY, Math.random())
        ];
      }
      function initParticles(){
        for (let i=0;i<particleCount;i++){
          const [x,y] = randXY();
          positions[i*3+0] = x;
          positions[i*3+1] = y;
          positions[i*3+2] = (Math.random()*2-1) * Z_RANGE;
          velocities[i*3+0] = (Math.random()-0.5)*0.25;
          velocities[i*3+1] = (Math.random()-0.5)*0.25;
          velocities[i*3+2] = (Math.random()-0.5)*0.07;
          targets[i*3+0]=999; targets[i*3+1]=999; targets[i*3+2]=0;
        }
        geom.attributes.position.needsUpdate = true;
        geom.attributes.velocity.needsUpdate = true;
        geom.attributes.target.needsUpdate   = true;
      }

      rebuildTextMappingAndHash();
      // 원하는 수 재산정(텍스트 수 고려) 및 재할당
      const wantByArea = Math.floor((innerWidth*innerHeight)/SWARM_DENSITY);
      const minForText = Math.ceil(textForMap.length*1.1);
      particleCount = Math.min(MAX_PARTICLES, Math.max(wantByArea, minForText));
      if (positions.length !== particleCount*3){
        positions = new Float32Array(particleCount*3);
        velocities= new Float32Array(particleCount*3);
        targets   = new Float32Array(particleCount*3);
        attachBuffers();
      }
      initParticles();

      // ---------- 전역 결집 토글(스페이스)
      let assembling = false;
      let assembleInstant = false;
      // 매핑: 텍스트 포인트 ↔ 파티클 인덱스 균등 샘플
      function globalMappedPairs(){
        const mapCount = Math.min(textForMap.length, particleCount);
        const particleIdx = Array.from({length: particleCount}, (_,i)=>i);
        for (let i=particleIdx.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [particleIdx[i], particleIdx[j]]=[particleIdx[j], particleIdx[i]]; }
        const pairs = [];
        for (let k=0;k<mapCount;k++){ pairs.push([particleIdx[k], textForMap[k]]); }
        return pairs;
      }
      let globalPairsCache = globalMappedPairs();

      function assembleText(instant=false){
        const tar = geom.attributes.target.array;
        globalPairsCache.forEach(([pi,tp])=>{
          const j = pi*3; tar[j+0]=tp.x; tar[j+1]=tp.y; tar[j+2]=0;
        });
        geom.attributes.target.needsUpdate = true;
        assembling = true; assembleInstant = instant;
      }
      function releaseText(){
        const tar = geom.attributes.target.array;
        for (let i=0;i<tar.length;i+=3){ tar[i]=tar[i+1]=999; tar[i+2]=0; }
        geom.attributes.target.needsUpdate = true;
        assembling = false;
      }
      // 초기 살짝 보여주고 해산
      setTimeout(()=> assembleText(false), 900);
      setTimeout(()=> releaseText(), 900 + 2600);
      addEventListener('keydown', (e)=>{ if (e.code==='Space'){ if (assembling) releaseText(); else assembleText(false); } });

      // ---------- 마우스 & hover reveal
      const mouseNdc = new THREE.Vector2(0,0);
      const mouseWorld = new THREE.Vector3();
      const plane = new THREE.Plane(new THREE.Vector3(0,0,1), 0); // z=0
      const raycaster = new THREE.Raycaster();
      let mouseActive = false;
      let lastOnTextMs = 0;

      function onPointer(e){
        mouseNdc.x = (e.clientX / innerWidth) * 2 - 1;
        mouseNdc.y = -(e.clientY / innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouseNdc, camera);
        raycaster.ray.intersectPlane(plane, mouseWorld);
        mouseActive = true;
      }
      addEventListener('pointermove', onPointer);
      addEventListener('pointerdown', onPointer);

      function mouseOverText(){
        const m = 0.02;
        const x = mouseWorld.x, y = mouseWorld.y;
        return (x > textRect.x - m && x < textRect.x + textRect.w + m &&
                y < textRect.y - m && y > textRect.y + textRect.h - m);
      }

      // 텍스트 근처 타깃을 빠르게 찾기(텍스트 해시 사용)
      function claimTargetsAround(mx,my,count=CLAIM_BATCH){
        const cx = t_ix(mx), cy = t_iy(my);
        const cand = [];
        for (let oy=-1; oy<=1; oy++){
          for (let ox=-1; ox<=1; ox++){
            const arr = textHash.get(tkey(cx+ox, cy+oy)); if (!arr) continue;
            for (let k=0;k<arr.length;k++){
              const i = arr[k];
              const tp = textForMap[i];
              const dx = tp.x - mx, dy = tp.y - my;
              const d2 = dx*dx + dy*dy;
              if (d2 < REVEAL_RADIUS*REVEAL_RADIUS) cand.push({i, d2});
            }
          }
        }
        cand.sort((a,b)=>a.d2-b.d2);
        return cand.slice(0, count).map(o=>o.i);
      }

      // 빈 파티클(타깃 미할당) 중 일부를 뽑아 타깃 부여
      function assignTargetsToFreeParticles(tpIndices){
        const tar = geom.attributes.target.array;
        const total = tar.length/3;
        let assigned = 0;
        for (let n=0; n<tpIndices.length; n++){
          // 랜덤 파티클부터 탐색(최대 8회 시도)
          for (let tryN=0; tryN<8; tryN++){
            const idx = (Math.random()*total)|0;
            if (tar[idx*3]===999){
              const tp = textForMap[tpIndices[n]];
              tar[idx*3+0]=tp.x; tar[idx*3+1]=tp.y; tar[idx*3+2]=0;
              assigned++; break;
            }
          }
          if (assigned >= CLAIM_BATCH) break;
        }
        if (assigned>0) geom.attributes.target.needsUpdate = true;
      }

      // ---------- 공간 해시(파티클)
      const hash = new Map();
      const SEP_R2 = SEP_RADIUS*SEP_RADIUS;
      function key(ix,iy,iz){ return (ix<<20) ^ (iy<<10) ^ iz; }
      const ix = (x)=> Math.floor((x - bounds.minX)/HASH_CELL);
      const iy = (y)=> Math.floor((y - bounds.minY)/HASH_CELL);
      const iz = (z)=> Math.floor((z + Z_RANGE)/HASH_CELL);

      // ---------- 루프
      let lastT = performance.now()*0.001;
      let frame = 0;

      function animate(){
        requestAnimationFrame(animate);
        const t  = performance.now()*0.001;
        const dt = Math.min(0.033, (t - lastT)); lastT = t;
        frame = (frame + 1) | 0;

        points.rotation.z += SCENE_SLOW_SPIN * dt;

        const pos = geom.attributes.position.array;
        const vel = geom.attributes.velocity.array;
        const tar = geom.attributes.target.array;

        // Hover reveal 로직
        if (mouseActive && mouseOverText()){
          lastOnTextMs = performance.now();
          const nearIdx = claimTargetsAround(mouseWorld.x, mouseWorld.y, CLAIM_BATCH);
          if (nearIdx.length) assignTargetsToFreeParticles(nearIdx);
        } else {
          // 글자 밖으로 나간지 RELEASE_DELAY 지나면 자동 해산
          if (performance.now() - lastOnTextMs > RELEASE_DELAY && !assembling){
            releaseText();
          }
        }

        // 파티클 해시 리빌드
        hash.clear();
        for (let i=0;i<pos.length;i+=3){
          const k = key(ix(pos[i]), iy(pos[i+1]), iz(pos[i+2]));
          if (!hash.has(k)) hash.set(k, []);
          hash.get(k).push(i/3);
        }

        for (let i=0;i<pos.length;i+=3){
          let x=pos[i], y=pos[i+1], z=pos[i+2];
          let vx=vel[i], vy=vel[i+1], vz=vel[i+2];

          // 3D 흐름장(완만)
          const a = (x + y + z)*1.05 + t*0.8;
          const b = (x - y - z)*0.95 - t*1.0;
          const c = (y - z)*1.2 + t*0.6;
          const fx = Math.sin(a) - Math.cos(b)*0.55 + 0.18*Math.sin(1.6*z + t*0.7);
          const fy = Math.cos(a*0.9) + Math.sin(c)*0.55 - 0.18*Math.cos(1.3*z - t*0.5);
          const fz = (Math.sin(x*1.1 + t*0.6) + Math.cos(y*1.0 - t*0.8))*0.28;

          vx += fx * CURL_SCALE * dt;
          vy += fy * CURL_SCALE * dt;
          vz += fz * CURL_SCALE * dt * 0.8;

          // 마우스 유도(거리 감쇠)
          if (mouseActive){
            const dx = mouseWorld.x - x, dy = mouseWorld.y - y;
            const d2 = dx*dx + dy*dy;
            const R  = 0.6;
            const falloff = Math.exp(-d2/(R*R));
            vx += dx * MOUSE_PULL * falloff * dt;
            vy += dy * MOUSE_PULL * falloff * dt;
          }

          // 텍스트 결집 스프링
          const tx = tar[i], ty = tar[i+1], tz = tar[i+2];
          if (tx !== 999){
            const spring = assembleInstant ? REVEAL_SPRING*2.2 : REVEAL_SPRING;
            vx += (tx - x) * spring * dt;
            vy += (ty - y) * spring * dt;
            vz += (tz - z) * spring * dt * 0.6;

            const dx=tx-x, dy=ty-y, dz=tz-z;
            if (dx*dx + dy*dy + dz*dz < UNCLAIM_DIST*UNCLAIM_DIST){
              vx*=0.7; vy*=0.7; vz*=0.7; // 도착 흔들림 억제
            }
          }

          // 근접 분리(격프레임)
          if ((frame % FLOCK_EVERY_N) === 0){
            let sx=0, sy=0, sz=0, cnt=0;
            const cx = ix(x), cy = iy(y), cz = iz(z);
            for (let oz=-1; oz<=1; oz++)
            for (let oy=-1; oy<=1; oy++)
            for (let ox=-1; ox<=1; ox++){
              const arr = hash.get(key(cx+ox, cy+oy, cz+oz)); if (!arr) continue;
              for (let k=0;k<arr.length;k++){
                const j = arr[k]*3; if (j===i) continue;
                const dx = x - pos[j], dy = y - pos[j+1], dz = z - pos[j+2];
                const d2 = dx*dx + dy*dy + dz*dz;
                if (d2>0.000002 && d2<SEP_R2){
                  const inv = 1.0/Math.max(0.0001, d2);
                  sx += dx*inv; sy += dy*inv; sz += dz*inv; cnt++;
                }
              }
            }
            if (cnt>0){ vx += (sx/cnt) * SEP_FORCE * dt;
                        vy += (sy/cnt) * SEP_FORCE * dt;
                        vz += (sz/cnt) * SEP_FORCE * dt; }
          }

          // 감쇠/속도제한/이동
          vx*=DAMP; vy*=DAMP; vz*=DAMP;
          const sp=Math.hypot(vx,vy,vz); if (sp>MAX_SPD){ const s=MAX_SPD/sp; vx*=s; vy*=s; vz*=s; }
          x += vx*dt; y += vy*dt; z += vz*dt;

          // 경계
          const B = 0.96;
          if (x<bounds.minX || x>bounds.maxX){ vx*=-B; x = THREE.MathUtils.clamp(x, bounds.minX, bounds.maxX); }
          if (y<bounds.minY || y>bounds.maxY){ vy*=-B; y = THREE.MathUtils.clamp(y, bounds.minY, bounds.maxY); }
          if (z<-Z_RANGE || z> Z_RANGE){      vz*=-B; z = THREE.MathUtils.clamp(z,-Z_RANGE, Z_RANGE); }

          pos[i]=x; pos[i+1]=y; pos[i+2]=z;
          vel[i]=vx; vel[i+1]=vy; vel[i+2]=vz;
        }

        geom.attributes.position.needsUpdate = true;
        geom.attributes.velocity.needsUpdate = true;

        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      // ---------- 리사이즈(프러스텀/텍스트 재계산 + 해시 갱신)
      addEventListener('resize', ()=>{
        camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
        computeBounds();
        const r = makeTextPoints(); textPoints = r.pts; textRect = r.rect;
        rebuildTextMappingAndHash();

        const wantByArea2 = Math.floor((innerWidth*innerHeight)/SWARM_DENSITY);
        const minForText2 = Math.ceil(textForMap.length*1.1);
        const newCount = Math.min(MAX_PARTICLES, Math.max(wantByArea2, minForText2));
        if (newCount !== particleCount){
          particleCount = newCount;
          positions = new Float32Array(particleCount*3);
          velocities= new Float32Array(particleCount*3);
          targets   = new Float32Array(particleCount*3);
          attachBuffers();
        }
        initParticles();
      });
    })();
  </script>
</body>
</html>
