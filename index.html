<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Vibe Murmuration 3D — Touch & Hover Letter Reveal</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Host+Grotesk:wght@500&display=swap" rel="stylesheet">
  <style>
    html,body{margin:0;height:100%;background:#0b0d10;overflow:hidden}
    #app{position:fixed;inset:0}
    #debug{position:fixed;left:12px;bottom:12px;color:#8fa;opacity:.8;font:12px/1.2 ui-monospace,monospace;white-space:pre}
    #hint{position:fixed;left:12px;top:12px;color:#89a;opacity:.75;font:12px/1.2 ui-monospace,monospace}
    canvas { touch-action: none; } /* 터치 스크롤/줌 방지 */
  </style>
</head>
<body>
  <div id="app"></div>
  <div id="debug"></div>
  <div id="hint">SPACE: 전체 결집/해산 · 마우스/터치: 글자 위에서 윤곽 드러남</div>

  <script type="module">
    import * as THREE from './lib/three.module.js';
    import { OrbitControls } from './lib/OrbitControls.js';
    const dbg = document.getElementById('debug');
    const log = (s)=>{ if(dbg) dbg.textContent = s; };
    async function tryImport(url){ try{ const m=await import(url); log('loaded: '+url); return m; }catch(e){ log('failed: '+url); return null; } }
    async function loadThree(){
      const sources = [
        { core:'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js',
          extra:'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/controls/OrbitControls.js' },
        { core:'https://unpkg.com/three@0.157.0/build/three.module.js',
          extra:'https://unpkg.com/three@0.157.0/examples/jsm/controls/OrbitControls.js' },
      ];
      for (const s of sources){
        const THREE = await tryImport(s.core); if(!THREE) continue;
        const Ex = await tryImport(s.extra);   if(!Ex) continue;
        return { THREE, OrbitControls: Ex.OrbitControls };
      }
      return null;
    }

    (async ()=>{
      const mod = await loadThree();
      if(!mod){ document.body.innerHTML='<div style="color:#9ad;display:grid;place-items:center;height:100%">외부 모듈 차단됨<br>HTTPS나 로컬브라우저에서 실행해봐</div>'; return; }
      const { THREE, OrbitControls } = mod;

      // ----- Parameters (생략: 그대로, 숫자들 동일) -----
      const TEXT_LINES = ['SPENT HOURS BACKFLOW','SLOWLY RISING ROUND MY SKIN','FOG DISSOLVES THE WALLS'];
      const FONT_FAMILY = "'Host Grotesk', sans-serif";
      const GRID_STEP=2, DOT_SIZE=0.014, SWARM_DENSITY=300, MAX_PARTICLES=12000, TEXT_MAP_RATIO=0.35;
      const CURL_SCALE=0.28,DAMP=0.98,MAX_SPD=1.2,MOUSE_PULL=0.55;
      const REVEAL_SPRING=6.8,UNCLAIM_DIST=0.012;
      const SEP_RADIUS=0.05,SEP_FORCE=0.6,HASH_CELL=0.08,FLOCK_EVERY_N=2;
      const Z_RANGE=0.7,SCENE_SLOW_SPIN=0.04;
      const REVEAL_RADIUS=0.26,CLAIM_BATCH=600,RELEASE_DELAY=450,PARTICLE_CLAIM_RADIUS=0.24;

      // ----- Scene -----
      const el=document.getElementById('app');
      const scene=new THREE.Scene();
      const camera=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.01,30);
      camera.position.set(0,0,1.7);
      const renderer=new THREE.WebGLRenderer({antialias:false,alpha:false,powerPreference:'high-performance'});
      renderer.setPixelRatio(Math.min(devicePixelRatio,1.5));
      renderer.setSize(innerWidth,innerHeight);
      el.appendChild(renderer.domElement);
      renderer.domElement.style.touchAction='none';
      const controls=new OrbitControls(camera,renderer.domElement);
      controls.enableDamping=true;controls.enableZoom=false;controls.enablePan=false;
      scene.fog=new THREE.FogExp2(0x0b0d10,1.1);

      // ----- bounds / text point generation (생략: 그대로) -----
      const bounds={}; function computeBounds(){ const halfY=Math.tan(THREE.MathUtils.degToRad(camera.fov)*0.5)*camera.position.z; const halfX=halfY*camera.aspect; bounds.minX=-halfX-0.04; bounds.maxX=halfX+0.04; bounds.minY=-halfY-0.04; bounds.maxY=halfY+0.04; } computeBounds();
      function makeTextPoints(){ /* ... (이전 답변과 동일, pts+rect 반환) ... */ }
      let {pts:textPoints,rect:textRect}=makeTextPoints();
      let textForMap=[]; const textHash=new Map(); const T_HASH=HASH_CELL*0.8;
      function rebuildTextMappingAndHash(){ textForMap=textPoints.filter(()=>Math.random()<TEXT_MAP_RATIO); textHash.clear(); for(let i=0;i<textForMap.length;i++){ const p=textForMap[i]; const k=((Math.floor((p.x-bounds.minX)/T_HASH))<<16)^Math.floor((p.y-bounds.minY)/T_HASH); if(!textHash.has(k)) textHash.set(k,[]); textHash.get(k).push(i);} }
      rebuildTextMappingAndHash();

      // ----- particles (생략: 초기화 부분 동일) -----
      let particleCount=Math.min(MAX_PARTICLES,Math.floor((innerWidth*innerHeight)/SWARM_DENSITY));
      const geom=new THREE.BufferGeometry();
      let positions=new Float32Array(particleCount*3),velocities=new Float32Array(particleCount*3),targets=new Float32Array(particleCount*3);
      function attachBuffers(){ geom.setAttribute('position',new THREE.BufferAttribute(positions,3)); geom.setAttribute('velocity',new THREE.BufferAttribute(velocities,3)); geom.setAttribute('target',new THREE.BufferAttribute(targets,3)); } attachBuffers();
      const mat=new THREE.PointsMaterial({color:0xffffff,size:DOT_SIZE,sizeAttenuation:true,transparent:true,opacity:0.85,depthWrite:false});
      const points=new THREE.Points(geom,mat); scene.add(points);

      // init particles
      function initParticles(){ for(let i=0;i<particleCount;i++){ positions[i*3]=THREE.MathUtils.lerp(bounds.minX,bounds.maxX,Math.random()); positions[i*3+1]=THREE.MathUtils.lerp(bounds.minY,bounds.maxY,Math.random()); positions[i*3+2]=(Math.random()*2-1)*Z_RANGE; velocities[i*3]=(Math.random()-0.5)*0.25; velocities[i*3+1]=(Math.random()-0.5)*0.25; velocities[i*3+2]=(Math.random()-0.5)*0.07; targets[i*3]=999; targets[i*3+1]=999; targets[i*3+2]=0; } geom.attributes.position.needsUpdate=true;geom.attributes.velocity.needsUpdate=true;geom.attributes.target.needsUpdate=true; }
      initParticles();

      // ----- mouse/touch unified -----
      const mouseNdc=new THREE.Vector2(),mouseWorld=new THREE.Vector3(),mouseLocal=new THREE.Vector3();
      const plane=new THREE.Plane(new THREE.Vector3(0,0,1),0);const raycaster=new THREE.Raycaster();
      let mouseActive=false,touchMode=false,lastOnTextMs=0;
      function setFromClient(x,y){ mouseNdc.x=(x/innerWidth)*2-1; mouseNdc.y=-(y/innerHeight)*2+1; raycaster.setFromCamera(mouseNdc,camera); raycaster.ray.intersectPlane(plane,mouseWorld); mouseLocal.copy(mouseWorld); points.worldToLocal(mouseLocal); mouseActive=true; }
      function onPointer(e){ setFromClient(e.clientX,e.clientY); }
      addEventListener('pointermove',onPointer,{passive:true});
      addEventListener('pointerdown',onPointer,{passive:true});
      // touch
      renderer.domElement.addEventListener('touchstart',e=>{ if(!e.touches.length)return;touchMode=true;controls.enabled=false;setFromClient(e.touches[0].clientX,e.touches[0].clientY); e.preventDefault(); },{passive:false});
      renderer.domElement.addEventListener('touchmove',e=>{ if(!e.touches.length)return;setFromClient(e.touches[0].clientX,e.touches[0].clientY); e.preventDefault(); },{passive:false});
      renderer.domElement.addEventListener('touchend',()=>{touchMode=false;controls.enabled=true;setTimeout(()=>{if(!assembling)releaseText();},RELEASE_DELAY);},{passive:true});
      renderer.domElement.addEventListener('touchcancel',()=>{touchMode=false;controls.enabled=true;},{passive:true});

      // ----- hover detection (mouseLocal 사용) -----
      function mouseOverText(){ const m=0.02;const x=mouseLocal.x,y=mouseLocal.y; return (x>textRect.x-m&&x<textRect.x+textRect.w+m&&y<textRect.y-m&&y>textRect.y+textRect.h-m); }

      // claimTargetsAround / nearbyParticles / matchTargetsToNearbyParticles → 동일 (radius/batch 매개변수만 받아서 터치일 때 1.2배 확대)

      // ... animate 루프: hover 부분에서
      // const rr = touchMode ? REVEAL_RADIUS*1.25 : REVEAL_RADIUS;
      // const pr = touchMode ? PARTICLE_CLAIM_RADIUS*1.25 : PARTICLE_CLAIM_RADIUS;
      // const batch = touchMode ? Math.round(CLAIM_BATCH*1.2) : CLAIM_BATCH;
      // if(mouseActive && mouseOverText()) { const nearIdx=claimTargetsAround(mouseLocal.x,mouseLocal.y,batch,rr); matchTargetsToNearbyParticles(nearIdx,mouseLocal.x,mouseLocal.y,pr); }
      // ...

      // (나머지 dynamics/animate는 이전 답변 코드와 동일)
    })();
  </script>
</body>
</html>
