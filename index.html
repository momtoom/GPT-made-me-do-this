<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Vibe Murmuration 3D — Single File</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Host+Grotesk:wght@600&display=swap" rel="stylesheet">
  <style>
    html,body{margin:0;height:100%;background:#0b0d10;overflow:hidden}
    #app{position:fixed;inset:0}
    #debug{position:fixed;left:12px;bottom:12px;color:#8fa;opacity:.9;font:12px/1.2 ui-monospace,monospace;white-space:pre}
    #hint{position:fixed;left:12px;top:12px;color:#89a;opacity:.82;font:12px/1.2 ui-monospace,monospace}
    canvas{touch-action:none}
  </style>

  <!-- OrbitControls.js가 내부에서 'three'를 import하더라도 동작하도록 매핑 -->
  <script type="importmap">
  { "imports": { "three": "./lib/three.module.js" } }
  </script>
</head>
<body>
  <div id="app"></div>
  <div id="debug"></div>
  <div id="hint">마우스/터치: 글자 위에서 윤곽 드러남 · Space/A: 전체 결집/해산</div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from './lib/OrbitControls.js';

    const dbg = document.getElementById('debug');
    const log = s => { if (dbg) dbg.textContent = s; };

    // ===== 파라미터 =====
    const TEXT_LINES = [
      'SPENT HOURS BACKFLOW',
      'SLOWLY RISING ROUND MY SKIN',
      'FOG DISSOLVES THE WALLS'
    ];
    const FONT_FAMILY = "'Host Grotesk', sans-serif";

    const GRID_STEP = 1.6;          // 글자 샘플링 간격(px 낮을수록 촘촘)
    const MAX_PARTICLES = 15000;
    const SWARM_DENSITY = 260;      // 화면 픽셀당 입자 밀도
    const DOT_SIZE_BASE = 0.016;

    const DAMP = 0.985, MAX_SPD = 1.25, MOUSE_PULL = 0.65;
    const SPRING_TEXT = 14.0, SPRING_ASSEMBLE = 6.0;
    const RELEASE_DELAY = 450, UNCLAIM_DIST = 0.06;
    const REVEAL_RADIUS = 0.22, PARTICLE_CLAIM_RADIUS = 0.22, CLAIM_BATCH = 900;

    // ===== 씬 & 카메라 =====
    const root = document.getElementById('app');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 30);
    camera.position.set(0,0,1.7);

    const renderer = new THREE.WebGLRenderer({ antialias:false, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 1.6));
    renderer.setSize(innerWidth, innerHeight);
    root.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.enablePan = false; controls.enableZoom = false;

    scene.fog = new THREE.FogExp2(0x0b0d10, 0.16);

    // ===== 월드 경계 =====
    const bounds = {};
    function computeBounds(){
      const halfY = Math.tan(THREE.MathUtils.degToRad(camera.fov)*0.5) * camera.position.z;
      const halfX = halfY * camera.aspect;
      bounds.minX = -halfX-0.04; bounds.maxX = halfX+0.04;
      bounds.minY = -halfY-0.04; bounds.maxY = halfY+0.04;
      return { halfX, halfY };
    }
    let { halfX, halfY } = computeBounds();

    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      ({ halfX, halfY } = computeBounds());
      // 텍스트도 화면비에 맞춰 다시 샘플링하려면 아래 한 줄 활성화
      // ({ pts:textPoints, rect:textRect } = makeTextPoints());
    });

    // ===== 텍스트 → 포인트 샘플링 =====
    function makeTextPoints(){
      const W = 1200, H = 520;
      const cvs = document.createElement('canvas');
      const ctx = cvs.getContext('2d');
      cvs.width = W; cvs.height = H;

      ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#fff';
      ctx.font = `600 66px ${FONT_FAMILY}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      const lineH = 96, baseY = H/2 - lineH;
      TEXT_LINES.forEach((t,i)=> ctx.fillText(t, W/2, baseY + i*lineH));

      const img = ctx.getImageData(0,0,W,H).data;
      const pts = [];
      let minX= Infinity, maxX=-Infinity, minY= Infinity, maxY=-Infinity;

      const halfY = Math.tan(THREE.MathUtils.degToRad(camera.fov) * 0.5) * camera.position.z;
      const halfX = halfY * camera.aspect;
      const scale = 0.9;

      for (let y = 0; y < H; y += GRID_STEP) {
        for (let x = 0; x < W; x += GRID_STEP) {
          const a = img[(y * W + x) * 4 + 3];
          if (a > 140) {
            const nx = (x / W - 0.5);   // -0.5..+0.5
            const ny = (y / H - 0.5);
            const wx = nx * 2 * halfX * scale;
            const wy = -ny * 2 * halfY * scale;
      
            pts.push({ x: wx, y: wy });
      
            if (wx < minX) minX = wx; if (wx > maxX) maxX = wx;
            if (wy < minY) minY = wy; if (wy > maxY) maxY = wy;
          }
        }
      }
      return { pts, rect:{ minX, maxX, minY, maxY } };
    }

    // ===== 메인(IIFE) =====
    (async () => {
      // 폰트가 실제 로드될 때까지 대기 (중요)
      await document.fonts.ready;

      let { pts:textPoints, rect:textRect } = makeTextPoints();
      console.log('textPoints:', textPoints.length);
      log(`textPts=${textPoints.length}`);

      // --- 파티클 버퍼 준비 ---
      let particleCount = Math.min(MAX_PARTICLES, Math.floor((innerWidth*innerHeight)/SWARM_DENSITY));
      particleCount = Math.max(Math.min((textPoints.length*1.3)|0, MAX_PARTICLES), 1800);

      const DOT_SIZE = Math.max(DOT_SIZE_BASE, Math.min(0.024,
        DOT_SIZE_BASE * (800/Math.max(innerWidth, innerHeight)) * 1.6));

      const geom = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount*3);
      const velocities = new Float32Array(particleCount*3);
      const targets   = new Float32Array(particleCount*3);
      const targetIdx = new Int32Array(particleCount);       // 파티클이 점유한 텍스트 인덱스
      const ptOwner   = new Int32Array(textPoints.length);   // 텍스트 포인트를 점유한 파티클

      geom.setAttribute('position', new THREE.BufferAttribute(positions,3));
      geom.setAttribute('velocity', new THREE.BufferAttribute(velocities,3));
      geom.setAttribute('target',   new THREE.BufferAttribute(targets,3));

      const points = new THREE.Points(
        geom,
        new THREE.PointsMaterial({ color:0xffffff, size:DOT_SIZE, sizeAttenuation:true, transparent:true, opacity:.92, depthWrite:false })
      );
      scene.add(points);

      // 초기화
      for (let i=0;i<particleCount;i++){
        positions[i*3]   = THREE.MathUtils.lerp(bounds.minX,bounds.maxX,Math.random());
        positions[i*3+1] = THREE.MathUtils.lerp(bounds.minY,bounds.maxY,Math.random());
        positions[i*3+2] = (Math.random()*2-1)*0.7;
        velocities[i*3]   = (Math.random()-0.5)*0.25;
        velocities[i*3+1] = (Math.random()-0.5)*0.25;
        velocities[i*3+2] = (Math.random()-0.5)*0.07;
        targets[i*3]=999; targets[i*3+1]=999; targets[i*3+2]=0;
        targetIdx[i] = -1;
      }
      for (let t=0;t<textPoints.length;t++) ptOwner[t] = -1;

      // --- 입력 처리 ---
      const mouseNdc=new THREE.Vector2(), mouseWorld=new THREE.Vector3(), mouseLocal=new THREE.Vector3();
      const plane=new THREE.Plane(new THREE.Vector3(0,0,1),0);
      const raycaster=new THREE.Raycaster();
      let mouseActive=false, touchMode=false, lastOnTextMs=0, assembleAll=false;

      function setFromClient(x,y){
        mouseNdc.x = (x/innerWidth)*2-1;
        mouseNdc.y = -(y/innerHeight)*2+1;
        raycaster.setFromCamera(mouseNdc,camera);
        raycaster.ray.intersectPlane(plane,mouseWorld);
        mouseLocal.copy(mouseWorld);
        points.worldToLocal(mouseLocal);
        mouseActive=true;
      }
      addEventListener('pointermove', e=>setFromClient(e.clientX,e.clientY), {passive:true});
      addEventListener('pointerdown', e=>setFromClient(e.clientX,e.clientY), {passive:true});

      renderer.domElement.addEventListener('touchstart', e=>{
        if(!e.touches.length) return;
        touchMode=true; controls.enabled=false;
        setFromClient(e.touches[0].clientX,e.touches[0].clientY);
        e.preventDefault();
      }, {passive:false});
      renderer.domElement.addEventListener('touchmove', e=>{
        if(!e.touches.length) return;
        setFromClient(e.touches[0].clientX,e.touches[0].clientY);
        e.preventDefault();
      }, {passive:false});
      renderer.domElement.addEventListener('touchend', ()=>{
        touchMode=false; controls.enabled=true;
        setTimeout(()=>{ if(!assembleAll) releaseAll(); }, RELEASE_DELAY);
      }, {passive:true});

      addEventListener('keydown', e=>{
        if(e.code==='Space' || e.code==='KeyA'){
          assembleAll = !assembleAll;
          if(!assembleAll) releaseAll();
        }
      });

      // --- 유틸 ---
      function mouseOverText(){
        const x = mouseLocal.x, y = mouseLocal.y;
        return (x>textRect.minX && x<textRect.maxX && y>textRect.minY && y<textRect.maxY);
      }
      function releaseAll(){
        for(let i=0;i<particleCount;i++){ targets[i*3]=999; targets[i*3+1]=999; targetIdx[i]=-1; }
        for(let t=0;t<textPoints.length;t++) ptOwner[t]=-1;
      }
      function claimAround(cx,cy,maxClaims,matchR){
        const r2 = matchR*matchR;
        let claimed=0;
        // 텍스트 포인트를 거칠게 샘플링하며 가까운 비할당 파티클을 붙임
        for(let t=0; t<textPoints.length && claimed<maxClaims; t+=2){
          if(ptOwner[t] !== -1) continue;
          const tp = textPoints[t];
          const dx0 = tp.x - cx, dy0 = tp.y - cy;
          if(dx0*dx0 + dy0*dy0 > r2) continue;

          let best=-1, bestd=1e9;
          for(let i=0;i<particleCount;i++){
            if(targetIdx[i] !== -1) continue;
            const dx = positions[i*3] - tp.x, dy = positions[i*3+1] - tp.y;
            const d = dx*dx + dy*dy;
            if(d<bestd && d<=r2){ best=i; bestd=d; }
          }
          if(best>=0){
            targetIdx[best]=t; ptOwner[t]=best;
            targets[best*3]=tp.x; targets[best*3+1]=tp.y; targets[best*3+2]=0;
            claimed++;
          }
        }
        return claimed;
      }
      function unclaimFar(){
        const th2 = UNCLAIM_DIST*UNCLAIM_DIST;
        for(let i=0;i<particleCount;i++){
          const ti = targetIdx[i]; if(ti<0) continue;
          const tp = textPoints[ti];
          const dx = positions[i*3]-tp.x, dy=positions[i*3+1]-tp.y;
          if(dx*dx+dy*dy > th2){
            targetIdx[i]=-1; ptOwner[ti]=-1;
            targets[i*3]=999; targets[i*3+1]=999;
          }
        }
      }
      function assembleAllNow(){
        const pr = 0.35, pr2 = pr*pr;
        for(let t=0;t<textPoints.length;t++){
          if(ptOwner[t] !== -1) continue;
          const tp = textPoints[t];
          let best=-1, bestd=1e9;
          for(let i=0;i<particleCount;i++){
            if(targetIdx[i] !== -1) continue;
            const dx=positions[i*3]-tp.x, dy=positions[i*3+1]-tp.y;
            const d=dx*dx+dy*dy;
            if(d<bestd && d<=pr2){ best=i; bestd=d; }
          }
          if(best>=0){
            targetIdx[best]=t; ptOwner[t]=best;
            targets[best*3]=tp.x; targets[best*3+1]=tp.y; targets[best*3+2]=0;
          }
        }
      }

      // --- 루프 ---
      let tick=0, lastAssembleApply=0;
      function animate(){
        requestAnimationFrame(animate);

        if(mouseActive && mouseOverText()){
          const rr = touchMode ? REVEAL_RADIUS*1.25 : REVEAL_RADIUS;
          const pr = touchMode ? PARTICLE_CLAIM_RADIUS*1.25 : PARTICLE_CLAIM_RADIUS;
          const batch = touchMode ? Math.round(CLAIM_BATCH*1.2) : CLAIM_BATCH;
          const got = claimAround(mouseLocal.x, mouseLocal.y, batch, rr);
          if(got>0) lastOnTextMs = performance.now();
        }else{
          if(performance.now() - lastOnTextMs > RELEASE_DELAY && !assembleAll){
            unclaimFar();
          }
        }

        if(assembleAll && tick - lastAssembleApply > 10){
          assembleAllNow();
          lastAssembleApply = tick;
        }
        tick++;

        for(let i=0;i<particleCount;i++){
          const pi=i*3;
          let vx=velocities[pi], vy=velocities[pi+1], vz=velocities[pi+2];
          let px=positions[pi],  py=positions[pi+1],  pz=positions[pi+2];

          const ti = targetIdx[i];
          if(ti>=0){
            const tp = textPoints[ti];
            const k = assembleAll ? SPRING_ASSEMBLE : SPRING_TEXT;
            vx += (tp.x - px) * (k*0.03);
            vy += (tp.y - py) * (k*0.03);
            vz += (0 - pz) * 0.02;
          }else if(mouseActive){
            const dx = mouseLocal.x - px, dy = mouseLocal.y - py;
            const d2 = dx*dx + dy*dy + 1e-4;
            const f = (MOUSE_PULL*0.003) / d2;
            vx += dx*f; vy += dy*f;
          }

          vx*=DAMP; vy*=DAMP; vz*=DAMP;
          const sp = Math.hypot(vx,vy); if(sp>MAX_SPD){ const s=MAX_SPD/sp; vx*=s; vy*=s; }

          px += vx*0.016; py += vy*0.016; pz += vz*0.016;

          // 경계 래핑
          if(px<bounds.minX) px=bounds.maxX; if(px>bounds.maxX) px=bounds.minX;
          if(py<bounds.minY) py=bounds.maxY; if(py>bounds.maxY) py=bounds.minY;

          velocities[pi]=vx; velocities[pi+1]=vy; velocities[pi+2]=vz;
          positions[pi]=px;  positions[pi+1]=py;  positions[pi+2]=pz;
        }

        geom.attributes.position.needsUpdate = true;
        controls.update();
        renderer.render(scene, camera);

        dbg.textContent = `textPts=${textPoints.length} · particles=${particleCount}`;
      }
      animate();
    })();
  </script>
</body>
</html>
