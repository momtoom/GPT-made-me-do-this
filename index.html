<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Vibe Murmuration 3D — full bleed</title>
  <!-- 폰트(글자 모양 안정화) -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Host+Grotesk:wght@500&display=swap" rel="stylesheet">
  <style>
    html,body{margin:0;height:100%;background:#0b0d10;overflow:hidden}
    #app{position:fixed;inset:0}
    #debug{position:fixed;left:12px;bottom:12px;color:#8fa;opacity:.75;
           font:12px/1.2 ui-monospace,monospace;white-space:pre}
    #hint{position:fixed;left:12px;top:12px;color:#89a;opacity:.7;
          font:12px/1.2 ui-monospace,monospace}
  </style>
</head>
<body>
  <div id="app"></div>
  <div id="debug"></div>
  <div id="hint">SPACE: 글자 토글 · 마우스: 유도</div>

  <script type="module">
    // --- safe logger
    const dbg = document.getElementById('debug');
    const log = (s)=>{ if(dbg) dbg.textContent = s; };

    async function tryImport(url){
      try{ const m = await import(url); log('loaded: '+url); return m; }
      catch(e){ log('failed: '+url); return null; }
    }
    async function loadThree(){
      const sources = [
        { core:'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js',
          extra:'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/controls/OrbitControls.js' },
        { core:'https://unpkg.com/three@0.157.0/build/three.module.js',
          extra:'https://unpkg.com/three@0.157.0/examples/jsm/controls/OrbitControls.js' },
        { core:'https://esm.sh/three@0.157.0',
          extra:'https://esm.sh/three@0.157.0/examples/jsm/controls/OrbitControls.js' }
      ];
      for (const s of sources){
        const THREE = await tryImport(s.core); if(!THREE) continue;
        const Ex = await tryImport(s.extra);   if(!Ex) continue;
        return { THREE, OrbitControls: Ex.OrbitControls };
      }
      return null;
    }

    (async ()=>{
      const mod = await loadThree();
      if(!mod){
        const warn = document.createElement('div');
        warn.style.position='fixed'; warn.style.inset='0'; warn.style.display='grid';
        warn.style.placeItems='center'; warn.style.color='#9ad';
        warn.style.font='14px ui-monospace,monospace'; warn.style.textAlign='center';
        warn.innerHTML = `External module import blocked.<br>
로컬 브라우저에서 이 파일을 직접 열어주세요.`;
        document.body.appendChild(warn);
        return;
      }
      const { THREE, OrbitControls } = mod;

      // ===== 파라미터 =====
      const TEXT_LINES = [
        'SPENT HOURS BACKFLOW',
        'SLOWLY RISING ROUND MY SKIN',
        'FOG DISSOLVES THE WALLS'
      ];
      const FONT_FAMILY = "'Host Grotesk', system-ui, -apple-system, Segoe UI, Roboto, sans-serif";

      const GRID_STEP = 2;                 // (유지) 글자 해상도
      const DOT_SIZE  = 0.028;             // 0.022 → 0.028 : 적은 입자라도 또렷하게
      const SWARM_DENSITY = 520;           // 250 → 520 : 화면당 입자 수 ↓ (노이즈 컷)
      const EXTRA_PARTICLE_MULT = 1.02;    // 1.1 → 1.02 : 텍스트 대비 여분 축소(과밀 방지)
      
      const CURL_SCALE = 0.42;             // 0.65 → 0.42 : 흐름장 세기 낮춤(요동 완화)
      const DAMP = 0.975;                  // 0.965 → 0.975 : 감쇠 강화로 미세 떨림 제거
      const MAX_SPD = 1.3;                 // 1.9 → 1.3 : 최대 속도 제한
      const MOUSE_PULL = 0.45;             // 0.55 → 0.45 : 마우스 흡인 약화(아래 거리감쇠랑 함께 적용)
      
      const REVEAL_SPRING = 6.8;           // (소폭 ↑) 글자 모일 때 더 안정적으로
      const UNCLAIM_DIST  = 0.012;
      const SEP_RADIUS = 0.035;
      const SEP_FORCE  = 0.8;              // 0.85 → 0.8 : 과도한 분리력 약간 완화
      const HASH_CELL  = 0.06;
      
      const Z_RANGE = 0.6;                 // 0.75 → 0.6 : 깊이 범위 살짝 축소(원근 노이즈 감소)
      const SCENE_SLOW_SPIN = 0.04;        // 0.07 → 0.04 : 장면 회전 느리게(시각적 안정감)

      // ===== Scene =====
      const el = document.getElementById('app');
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 30);
      camera.position.set(0,0,1.7);

      const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(innerWidth, innerHeight);
      renderer.setClearColor(0x0b0d10, 1);
      el.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; controls.enableZoom = false; controls.enablePan = false;

      scene.fog = new THREE.FogExp2(0x0b0d10, 1.15);

      // 화면을 꽉 채우는 월드 경계 산출(카메라 프러스텀 기준, z=0 평면)
      const bounds = { minX:0, maxX:0, minY:0, maxY:0 };
      function computeBounds(){
        const halfY = Math.tan(THREE.MathUtils.degToRad(camera.fov)*0.5) * camera.position.z;
        const halfX = halfY * camera.aspect;
        const padX = 0.04, padY = 0.04; // 화면 밖으로 살짝 여유
        bounds.minX = -halfX - padX; bounds.maxX = halfX + padX;
        bounds.minY = -halfY - padY; bounds.maxY = halfY + padY;
      }
      computeBounds();

      // ===== 텍스트 마스크 → 포인트 =====
      function makeTextPoints(){
        const W = Math.max(1280, innerWidth);
        const H = Math.max(720, innerHeight);
        const cvs = document.createElement('canvas');
        cvs.width = W; cvs.height = H;
        const ctx = cvs.getContext('2d', { willReadFrequently:true });

        // 화면 거의 가득(폭의 92%)으로 맞춤
        const base=100; ctx.font = `500 ${base}px ${FONT_FAMILY}`;
        const maxBase = TEXT_LINES.reduce((m,t)=>Math.max(m, ctx.measureText(t).width), 1);
        const target = Math.min(W*0.92, 2600);
        const fontPx = Math.max(18, Math.min(220, Math.round(base*(target/maxBase))));
        const lineH  = Math.round(fontPx*1.25);
        ctx.font = `500 ${fontPx}px ${FONT_FAMILY}`;
        ctx.textBaseline = 'top'; ctx.textAlign='left'; ctx.fillStyle='#fff';

        const maxLineW = TEXT_LINES.reduce((m,t)=>Math.max(m, ctx.measureText(t).width), 0);
        const baseX = Math.round((W - maxLineW)/2);
        const startY = Math.round((H - TEXT_LINES.length*lineH)/2);
        TEXT_LINES.forEach((t,i)=> ctx.fillText(t, baseX, startY + i*lineH));

        const minX = Math.max(0, baseX);
        const maxX = Math.min(W, baseX + maxLineW);
        const minY = Math.max(0, startY);
        const maxY = Math.min(H, startY + TEXT_LINES.length*lineH);

        const img = ctx.getImageData(minX, minY, maxX-minX, maxY-minY);
        const data = img.data, iw=img.width, ih=img.height;

        const pts = [];
        for (let y=0; y<ih; y+=GRID_STEP){
          for (let x=0; x<iw; x+=GRID_STEP){
            const a = data[(y*iw + x)*4 + 3];
            if (a>10){
              // 캔버스 좌표 → 월드 좌표로 균일 매핑(프러스텀 경계 사용)
              const nx = THREE.MathUtils.lerp(bounds.minX, bounds.maxX, (minX + x)/W);
              const ny = THREE.MathUtils.lerp(bounds.minY, bounds.maxY, 1 - (minY + y)/H);
              pts.push(new THREE.Vector3(
                nx + (Math.random()-0.5)*((bounds.maxX-bounds.minX)/W)*6,
                ny + (Math.random()-0.5)*((bounds.maxY-bounds.minY)/H)*6,
                0
              ));
            }
          }
        }
        const rect = {
          x: THREE.MathUtils.lerp(bounds.minX, bounds.maxX, minX/W),
          y: THREE.MathUtils.lerp(bounds.minY, bounds.maxY, 1 - minY/H),
          w: THREE.MathUtils.lerp(0, bounds.maxX-bounds.minX, (maxX-minX)/W),
          h: -THREE.MathUtils.lerp(0, bounds.maxY-bounds.minY, (maxY-minY)/H) // 위가 +
        };
        return { pts, rect };
      }

      const { pts: textPoints, rect: textRect } = makeTextPoints();

      // ===== 파티클 생성(화면을 꽉 채우도록 수량 보장) =====
      const wantByArea = Math.floor((innerWidth*innerHeight)/SWARM_DENSITY);
      const minForText = Math.ceil(textPoints.length * EXTRA_PARTICLE_MULT);
      const particleCount = Math.max(wantByArea, minForText);

      const geom = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount*3);
      const velocities = new Float32Array(particleCount*3);
      const targets   = new Float32Array(particleCount*3);

      function randXY(){ 
        return [
          THREE.MathUtils.lerp(bounds.minX, bounds.maxX, Math.random()),
          THREE.MathUtils.lerp(bounds.minY, bounds.maxY, Math.random())
        ];
      }
      for (let i=0;i<particleCount;i++){
        const [x,y] = randXY();
        positions[i*3+0] = x;
        positions[i*3+1] = y;
        positions[i*3+2] = (Math.random()*2-1) * Z_RANGE; // 깊이 분포

        velocities[i*3+0] = (Math.random()-0.5)*0.3;
        velocities[i*3+1] = (Math.random()-0.5)*0.3;
        velocities[i*3+2] = (Math.random()-0.5)*0.08;

        targets[i*3+0]=999; targets[i*3+1]=999; targets[i*3+2]=0;
      }
      geom.setAttribute('position', new THREE.BufferAttribute(positions,3));
      geom.setAttribute('velocity', new THREE.BufferAttribute(velocities,3));
      geom.setAttribute('target',   new THREE.BufferAttribute(targets,3));

      const mat = new THREE.PointsMaterial({
        color: 0xffffff,
        size: DOT_SIZE,
        sizeAttenuation: true,
        transparent: true,
        opacity: 0.85,                     // 0.95 → 0.85
        depthWrite: false,
        // blending: THREE.AdditiveBlending  // ❌ 지우기
        blending: THREE.NormalBlending      // ✅ 일반 블렌딩 (노이즈감 확 줄어듦)
      });

      const points = new THREE.Points(geom, mat);
      scene.add(points);

      // ===== 텍스트 매핑(1:1 할당) =====
      // 텍스트 포인트 개수만큼 파티클을 샘플링해서 고정 매핑 만듦
      const mapCount = Math.min(textPoints.length, particleCount);
      const particleIdx = Array.from({length: particleCount}, (_,i)=>i);
      // 넓게 퍼지도록 셔플 후 균등 샘플
      for (let i=particleIdx.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [particleIdx[i], particleIdx[j]]=[particleIdx[j], particleIdx[i]]; }
      const mappedPairs = [];
      for (let k=0;k<mapCount;k++){
        const pi = particleIdx[k];
        const tp = textPoints[k];
        mappedPairs.push([pi, tp]);
      }

      function assembleText(instant=false){
        const tar = geom.attributes.target.array;
        for (let i=0;i<mappedPairs.length;i++){
          const [pi, tp] = mappedPairs[i];
          const j = pi*3;
          tar[j+0] = tp.x;
          tar[j+1] = tp.y;
          tar[j+2] = 0; // 글자는 z=0 평면 위
        }
        geom.attributes.target.needsUpdate = true;
        assembling = true;
        assembleInstant = instant;
      }
      function releaseText(){
        const tar = geom.attributes.target.array;
        for (let i=0;i<tar.length;i+=3){ tar[i]=tar[i+1]=999; tar[i+2]=0; }
        geom.attributes.target.needsUpdate = true;
        assembling = false;
      }

      // ===== 마우스 월드 좌표 =====
      const mouseNdc = new THREE.Vector2(0,0);
      const mouseWorld = new THREE.Vector3();
      const plane = new THREE.Plane(new THREE.Vector3(0,0,1), 0); // z=0
      const raycaster = new THREE.Raycaster();
      function onPointer(e){
        mouseNdc.x = (e.clientX / innerWidth) * 2 - 1;
        mouseNdc.y = -(e.clientY / innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouseNdc, camera);
        raycaster.ray.intersectPlane(plane, mouseWorld);
        // 마우스가 화면 어디든 있으면 텍스트 결집에 힘 보탬
        mouseActive = true;
      }
      addEventListener('pointermove', onPointer);
      addEventListener('pointerdown', onPointer);

      // ===== 상태 플래그 =====
      let assembling = false;
      let assembleInstant = false;
      let mouseActive = false;

      // 초기 자동 리빌 → 유지 → 해산
      setTimeout(()=> assembleText(false), 1000);      // 1200 → 1000
      setTimeout(()=> releaseText(), 1000 + 3500);     // 2500 → 3500 (가독 시간 ↑)

      // Space 로 토글
      addEventListener('keydown', (e)=>{
        if (e.code==='Space'){
          if (assembling) releaseText(); else assembleText(false);
        }
      });

      // ===== 공간 해시 =====
      const hash = new Map();
      const SEP_R2 = SEP_RADIUS*SEP_RADIUS;
      function key(ix,iy,iz){ return (ix<<20) ^ (iy<<10) ^ iz; }
      const ix = (x)=> Math.floor((x - bounds.minX)/HASH_CELL);
      const iy = (y)=> Math.floor((y - bounds.minY)/HASH_CELL);
      const iz = (z)=> Math.floor((z + Z_RANGE)/HASH_CELL);

      // ===== 애니메이션 =====
      let lastT = performance.now()*0.001;

      function animate(){
        requestAnimationFrame(animate);
        const t  = performance.now()*0.001;
        const dt = Math.min(0.033, (t - lastT)); lastT = t;

        // 장면에 아주 느린 스핀을 줘서 파랄랙스 강화
        points.rotation.z += SCENE_SLOW_SPIN * dt;

        const pos = geom.attributes.position.array;
        const vel = geom.attributes.velocity.array;
        const tar = geom.attributes.target.array;

        // 해시 리빌드
        hash.clear();
        for (let i=0;i<pos.length;i+=3){
          const k = key(ix(pos[i]), iy(pos[i+1]), iz(pos[i+2]));
          if (!hash.has(k)) hash.set(k, []);
          hash.get(k).push(i/3);
        }

        // 메인 루프
        for (let i=0;i<pos.length;i+=3){
          let x=pos[i], y=pos[i+1], z=pos[i+2];
          let vx=vel[i], vy=vel[i+1], vz=vel[i+2];

          // 3D 흐름장(간단 curl-like) + 깊이 드리프트
          const a = (x + y + z)*1.1 + t*0.9;
          const b = (x - y - z)*1.0 - t*1.1;
          const c = (y - z)*1.3 + t*0.7;
          const fx = Math.sin(a) - Math.cos(b)*0.6 + 0.2*Math.sin(1.7*z + t*0.8);
          const fy = Math.cos(a*0.9) + Math.sin(c)*0.6 - 0.2*Math.cos(1.4*z - t*0.6);
          const fz = (Math.sin(x*1.2 + t*0.7) + Math.cos(y*1.1 - t*0.9))*0.32;

          vx += fx * CURL_SCALE * dt;
          vy += fy * CURL_SCALE * dt;
          vz += fz * CURL_SCALE * dt * 0.8;

          // 마우스 유도(거리 기반 감쇠: 가까울수록 강하게)
          if (mouseActive){
            const dx = mouseWorld.x - x;
            const dy = mouseWorld.y - y;
            const d2 = dx*dx + dy*dy;
            const R  = 0.6;                  // 영향 반경
            const falloff = Math.exp(-d2/(R*R)); // 부드러운 가우시안 감쇠
            vx += dx * MOUSE_PULL * falloff * dt;
            vy += dy * MOUSE_PULL * falloff * dt;
          }

          // 텍스트 결집 스프링
          const tx = tar[i], ty = tar[i+1], tz = tar[i+2];
          if (tx !== 999){
            const spring = assembleInstant ? REVEAL_SPRING*2.2 : REVEAL_SPRING;
            vx += (tx - x) * spring * dt;
            vy += (ty - y) * spring * dt;
            vz += (tz - z) * spring * dt * 0.6;

            const dx=tx-x, dy=ty-y, dz=tz-z;
            if (dx*dx + dy*dy + dz*dz < UNCLAIM_DIST*UNCLAIM_DIST){
              // 도착 시 미세 진동 방지
              vx*=0.7; vy*=0.7; vz*=0.7;
            }
          }

          // 근접 분리(3x3x3 셀)
          let sx=0, sy=0, sz=0, cnt=0;
          const cx = ix(x), cy = iy(y), cz = iz(z);
          for (let oz=-1; oz<=1; oz++)
          for (let oy=-1; oy<=1; oy++)
          for (let ox=-1; ox<=1; ox++){
            const arr = hash.get(key(cx+ox, cy+oy, cz+oz)); if (!arr) continue;
            for (let k=0;k<arr.length;k++){
              const j = arr[k]*3; if (j===i) continue;
              const dx = x - pos[j], dy = y - pos[j+1], dz = z - pos[j+2];
              const d2 = dx*dx + dy*dy + dz*dz;
              if (d2>0.000002 && d2<SEP_R2){
                const inv = 1.0/Math.max(0.0001, d2);
                sx += dx*inv; sy += dy*inv; sz += dz*inv; cnt++;
              }
            }
          }
          if (cnt>0){ vx += (sx/cnt) * SEP_FORCE * dt;
                      vy += (sy/cnt) * SEP_FORCE * dt;
                      vz += (sz/cnt) * SEP_FORCE * dt; }

          // 속도 제한 & 감쇠
          vx*=DAMP; vy*=DAMP; vz*=DAMP;
          const sp=Math.hypot(vx,vy,vz);
          if (sp>MAX_SPD){ const s=MAX_SPD/sp; vx*=s; vy*=s; vz*=s; }

          // 이동
          x += vx*dt; y += vy*dt; z += vz*dt;

          // 화면 끝에서 튕김(프러스텀 경계 기반)
          const B = 0.96;
          if (x<bounds.minX || x>bounds.maxX){ vx*=-B; x = THREE.MathUtils.clamp(x, bounds.minX, bounds.maxX); }
          if (y<bounds.minY || y>bounds.maxY){ vy*=-B; y = THREE.MathUtils.clamp(y, bounds.minY, bounds.maxY); }
          if (z<-Z_RANGE || z> Z_RANGE){      vz*=-B; z = THREE.MathUtils.clamp(z,-Z_RANGE, Z_RANGE); }

          pos[i]=x; pos[i+1]=y; pos[i+2]=z;
          vel[i]=vx; vel[i+1]=vy; vel[i+2]=vz;
        }

        geom.attributes.position.needsUpdate = true;
        geom.attributes.velocity.needsUpdate = true;

        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      // ===== 리사이즈 =====
      addEventListener('resize', ()=>{
        camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
        computeBounds(); // 프러스텀 경계 갱신(화면 꽉 채움 유지)
      });
    })();
  </script>
</body>
</html>


